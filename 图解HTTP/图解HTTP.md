# 图解HTTP

## 第一章 了解Web及网络基础
### 1.1 使用HTTP协议访问web

- 通过发送请求获取服务器资源的Web浏览器等，都可以称为**客户端(client)**
![][image-1]

### 1.3 网络基础TCP/IP
通常使用的网络（包括互联网）是在TCP/IP协议族的基础运作的。而HTTP属于它内部的一个子集。
#### 1.3.2 TCP/IP的分层管理
TCP/IP协议族按层次分为

- 应用层
	-  决定了向用户提供应用服务时通信的活动（例如FTP(File Transfer Protocol)/DNS(Domain Name System)等）
	- HTTP协议处于该层
- 传输层
	- 对上层应用层，提供了网络连接中的两台计算机之间的数据传输
	- 传输层有两个性质不同的协议：TCP(Transmission Control Protocol)和UDP(User Data Protocol)
- 网络层
	- 用来处理在网络上流动的数据包（是网络传输的最小数据）。
	- 规定了通过怎样的路径（就是传输路线）到达对方计算机，并把数据包传送给对方
- 数据链路层
	- 用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（网卡），及光纤等物理课件部分。硬件范畴均在链路层。

#### 1.3.3 TCP/IP 通信传输流
![][image-2]

利用TCP/IP协议族进行网络通信时，会通过分成顺序与对方进行通信。  
发送端从应用层往下走，接收端则往上走。  

**封装**：发送端在层与层之间的传输数据时，每经过一层时必定会被打上一个改层所属的首部信息。反之，接收端在层与层传输数据时，每经过一一层时，会把对应的首部消去。

### 1.4 与HTTP关系密切的协议:IP、TCP和DNS
#### 1.4.1 负责传输的IP协议
IP（Internet Protocol）网际协议位于网络层 ，是协议名称，有别于IP地址 
作用就是把各种数据包传送给对方，为确保传送到对方那里，需要满足条件，其中两个重要的条件是IP地址和MAC地址

- IP地址指明了节点分配的地址（可变换）
- MAC地址指的是网卡所属的固定地址（基本不会改）
- 使用ARP协议凭借MAC地址进行通信
- IP间的通信以来MAC地址，因为通信双方在同一个局域网内的情况很少，在进行中转时，会利用下一站中转设备的MAC地址来搜索下一个中转目标。
	- 这时采用ARP协议（Address Resolution Protocol），是一种用以解析地址的协议，根据通信方的IP地址就可以反查出对应的MAC地址。

![][image-3]

#### 1.4.2 确保可靠性的TCP协议
桉层次分，TCP位于传输层，提供可靠的字节流服务。
也就是，TCP协议为了更容易传送大数据才把数据分割，而且TCP协议能够确认数据最终是否送达到对方。

为了准确无误地将数据送达目标处，TCP协议采用了**三次握手**策略。（使用了TCP的标准——SYN（synchronize）和ACK（acknowledge））

- 发送端首先发送一个带SYN标志的数据包给对方
- 接收端收到后回传一个带有SYN/ACK标志的数据包以示传达确认信息
- 发送端再回传一个带ACK标准的数据包，代表握手结束

### 1.5 负责域名解析的DNS服务
DNS（Domain Name System）服务是和HTTP协议一样位于应用层的协议。提供域名和IP地址之间的解析服务。  
用户通常通过主机名或域名来访问对方的计算机，而不是直接通过IP地址。  
计算机不理解名称，更擅长处理一长串数字。  
DNS协议提供通过域名查找IP地址，或逆向从IP地址反查域名的服务

### 1.6 各种协议与HTTP协议的关系
![][image-4]

### 1.7 URI 和URL
与URI（统一资源标识符）相比，我们更熟悉URL（Uniform Resource Locator，统一资源定位符）。
#### 1.7.1 URI 统一资源标识符
URI = Uniform Resource Identifier  
URI用字符串标识某一互联网资源，而URL表示资源的地点（互联网上所处的位置）。URL是URI的子集。


#### 1.7.2 URI格式

- 绝对URI
	- 使用http或者https等协议方案名获取访问资源时要指定协议类型。最后附一个冒号：
- 绝对URL
- 相对URL：指从浏览器中基本URI处指定的URL，形如/image/logo.gif
- …

## 第二章 简单的HTTP协议
### 2.1 HTTP协议用于客户端和服务器端之间
应用HTTP协议时，必定一端是客户端，一端是服务器端。

### 2.2
HTTP协议规定，请求从客户端发出，最后服务器端响应请求并返回。服务器端在没有接到请求之前是不会发送响应的。
![][image-5]

请求报文：  

- 方法（method）：GET/POST
- 请求URI（request-URI）：e.g /index.htm
- HTTP版本号，用来提示客户端使用的HTTP协议功能。 e.g HTTP/1.1
- (可选)请求首部字段
- (可选)内容实体

![][image-6]

响应报文：

- HTTP版本号
- 状态码
- 状态码的原因短语
- (可选)创建响应的日期时间，是首部字段内的一个属性
- (可选)主体

### 2.3 HTTP是不保存状态的协议
HTTP是一种不保存状态的协议，即无状态协议。HTTP协议自身不对请求和响应之间的通信状态进行保存。  
为了保存状态功能，引入了Cookie技术。

### 2.4 请求URI定位资源
URI的特定功能，在互联网上任意位置的资源都能访问到。  
HTTP协议使用URI让客户端定位资源  
当客户端请求访问资源而发送请求时，URI需要将作为请求报文中的请求URI包含在内。如果不是访问特定资源，而是对服务器本身发起请求，可以用一个\*来代替URI。`OPTIONS * HTTP/1.1`

### 2.5 告知服务器意图的HTTP方法
HTTP/1.1中可以使用的方法：

- GET：获取资源
- POST： 传输实体主体
- PUT：传输文件 （不带验证机制，存在安全问题。一般不使用）
- HEAD：获得报文首部
	- 和GET方法一样，只是不返回报文主题部分。
	- 用于确认URI的有效性及资源更新的日期时间等

- DELETE：删除文件
	- 与PUT相反，按请求URI删除指定的资源
	- 同样不带验证机制，存在安全问题。一般不使用

- OPTIONS：询问支持的方法
	- 查询针对请求URI指定的资源支持的方法
![][image-7]

- TRACE:追踪路径
	- 不常用，容易引发XST攻击（跨站追踪）
- CONNECT：要求用隧道协议链接代理
	- 要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL和TLS协议把通信内容加密后经网络隧道传输

### 2.7 持久连接节省通信量
只要任意一端没有明确提出断开连接，则保持TCP连接状态

#### 2.7.2 管线化：
持久连接使得多数请求以管线化方式发送成为可能。以前发送请求后需要等待并收到响应才能发生下一个请求。管线化技术的出现，不用等待响应亦可直接发送下一个请求。这样可以同时并行发送多个请求。

### 2.8 使用Cookie的状态管理
Cookie会根据从服务器端发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在报文中加入Cookie值发送出去。  
服务器端发现客户端发送过来的Cookie后，检查从哪一个客户端发来的连接请求，然后对比服务器的记录，最后得到之前的状态信息。

## 第三章 HTTP报文内的HTTP信息
### 3.1 HTTP报文
HTTP报文大致可分为报文首部和报文主体两块。两者由最初出现的空行（回车符➕换行符）来划分。不一定要有报文主体。

- 报文首部：服务器端或者客户端需处理的请求或响应的内容及属性
- 报文主体：应被发送的数据

### 3.2 请求报文及响应报文的结构

- 请求行/状态行
	- 请求行：包含用于请求的方法，请求URI和HTTP版本
	- 状态行：包含表明响应结果的状态码，原因短语和HTTP版本

- 首部字段：包含请求和新颖的各种条件和属性的各类首部
	- 通用首部
	- 请求首部
	- 响应首部
	- 实体首部
	- （可能包含HTTP和RFC里未定义的首部（Cookie等））。

### 3.3编码提升传输速率
#### 3.3.1 报文主体和实体主体的差异

- 报文（message）
	- HTTP通信的基本单位
	- 8位组字节流组成
	- 通过HTTP通信传输

- 实体（entity）
	- 作为请求或者响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成

HTTP报文的主体用于传输请求或者响应的实体主体。  
通常，报文主体等于实体主体。  
只有当传输中进行编码操作时，实体主体的内容发生变化，才有差异。

#### 3.3.2 压缩传输的内容编码
HTTP协议中有一种被称为内容编码的功能也能进行类似ZIP压缩的操作。  
内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩。  
内容编码后的实体由客户端接收并且负责解码。  
常见内容编码有以下几种： 

- gzip
- compress
- delate
- identity

#### 3.3.3 分割发送的分块传输编码
在HTTP通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。  
在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。  
这种把实体主体分块的功能称为分块传输编码。

#### 3.4 发送多种数据的多部分对象集合
HTTP协议中采用了多部分对象集合，发送一份报文主体内可含有多类型的实体。通常是在图片或文本文件等上传时使用。  
多部分对象集合包含的对象如下：

- multipart/form-data
	- 在Web表单文件上传使用
- multipart/byterangers
	- 状态码206（Partial Content，部分内容）响应报文包含了多个范围的内容时使用。
![][image-8]
![][image-9]

在HTTP报文中使用多部分对象集合时，需要在首部字段里加上`Content-type`  
使用boundary字符串来划分多部分对象集合指明的各类实体。 在各个实体的起始行之前插入“\-\-”标记(例如：\-\-AaB03x-\-、-\-THIS\_STRING\_SEPARATES-\-）作为结束

### 3.5 获取部分内容的范围请求
以前不使用高速网络，如果下载网络中断就必须重新开始。为解决这个问题，需要一种可恢复机制。  
要实现该功能需要指定下载的实体范围。  
指定范围发送的请求叫做范围请求（range request）  

执行范围请求时，会用到`Range`来指定资源的byte范围。

	byte范围的指定形式如下：
	        5001~10000字节
	        Range:bytes=5001~10000
	        从5001字节之后全部的
	        Range: byte=5001-
	        从一开始到3000字节和5000~7000字节的多重范围
	        Range: byte=-3000, 5000-7000

针对范围请求，响应会返回状态码206 Partial Content的响应报文。  
对于多重范围的范围请求，响应会在首部字段`Content-Type`标明`multipart/byteranges`后返回响应报文  
如果服务器无法响应范围请求，则会但会状态码200 OK和完整的实体内容。

### 3.6 内容协商返回最合适的内容
同一个web网站可能保存多份相同内容的页面。比如英语版和中文版的WEB页面，内容虽相同，语言却不同。  
但浏览器的默认语言为英语或中文，访问相同URI的web页面时，则会显示对应的英语版或者中文版。这样的机制成为**内容协商（Content Negotiation）**  

内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源，内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准。

包含在请求报文中的某些首部字段就是判断基准：

- Accept
- Accept-Charset
- Accept-Encoding
- Accept-Language
- Content-Language

内容协商技术有以下3种类型：

- 服务器驱动协商（server-driven Negotiation）
	- 以请求的首部字段为参考，在服务器自动处理。但不一定是最优内容
- 客户端驱动协商（agent-driven negotiation）
	- 用户从浏览器显示的可选项列表手动选择。还可以利用JavaScript脚本在web页面上自动进行上述选择。例如按OS的类型或者浏览器类型，自行切换成PC版网页或手机版网页
- 透明协商（Transparent Negotiation）
	- 两种的结合体。各自进行内容协商的一种方法。

## 第四章 返回结果的HTTP状态码
HTTP状态码负责表示客服端HTTP请求的返回结果、标记服务器端的处理是否正常、通知出现的错误等工作。

状态码的第一位指定了响应类别。  
状态码的类别：

- 1XX（Informational 信息性） 接收的请求正在处理
- 2XX （Success 成功状态码）请求正常处理完毕
- 3XX （Redirection 重定向状态码）需要进行附加操作以完成请求
- 4XX （Client Error 客户端错误状态码）服务器无法处理请求
- 5XX （Server Error 服务器错误状态码）服务器处理请求出错

### 4.2 2XX 成功 success
请求正常处理完毕

- 200 OK 
	- 表示从客服端发来的请求在服务器端被正常处理了

在响应报文内，随状态码一起返回的信息会因方法的不同而发生变化。  
使用GET方法时，对应请求资源的实体会作为响应返回。  
使用HEAD方法时，对应请求资源的实体首部不随报文主体作为响应返回。（即在响应中只返回首部，不会返回实体的主体部分）

- 204 No Content
	-  请求处理成功！但没有资源可返回。
	- 一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。

- 206 Partial Content
	- 表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。
	- 响应报文中包含由Content-Range指定范围的实体内容。

### 4.3 3XX 重定向 redirection
表明浏览器需要执行某些特殊的处理以正确处理请求

- 301 Moved Permanently
	- 永久性重定向
	- 请求的资源以及被分配了新的URI，以后应使用资源现在所指定的URI。
	- 如果以及把URI保存为书签，这时应该按Locaiton首部字段提示的URI重新保存
	- 例如这个路径最后忘记添加‘/’,就会产生301状态码`http://example.com/sample`

- 302 Found
	- 临时性重定向
	- 表示请求的资源已被分配了新的URI，希望用户（本次）能使用新的URI访问
	- 与301对比，302是临时性的，已移动的资源对应的URI将来还有可能发生改变。
	- 用户把URI保存成书签，但不会像301状态码那样去更新书签，而是仍旧保留返回302状态码的页面对应的URI

- 303 See Other
	- 表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。
	- 303和302有着相同的功能，但303明确表示客户端应当采用GET方法获取资源。

当301、302、303响应状态码返回时，几乎所有浏览器都会把POST改成GET，并删除请求报文内的主体，之后请求会自动再次发送。  
301、302标准是禁止将POST改变成GET方法的，但实际使用时大家都会这么做。

- 304 Not Modified
	- 表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。
	- 304返回时，不包含任何响应的主体部分。
	- 304虽然被划分在3XX类别中，但是和重定向没有关系。

- 307 Temporary Redirect
	- 临时重定向。与302有相同含义，尽管302标准禁止POST变换成GET,但大家并不遵守。
	- 307会遵守浏览器标准，不会从POST变成GET。但是，对于处理响应时的行为，每种浏览器有可能出现不同的情况。

### 4.4 4XX客户端错误 client error
表明客户端是发生错误的原因所在。

- 400 Bad Request
	- 表示请求报文中存在语法错误。
	- 当错误发生时，需修改请求的内容后再次发送请求。
	- 浏览器会像200 OK一样对待该状态码。

- 401 Unauthorized 
	- 表示发送的请求需要有通过HTTP认证的认证信息。
	- 若之前已经进行过1次请求，则表示用户认证失败。
	- 返回含有401的响应必须包含一个适用于被请求资源的WWW-Authenticate首部用以质询用户信息。初次接到401响应时，会弹出认证用的对话窗口。

- 403 Forbidden
	- 表明对请求资源的访问被服务器拒绝了。
	- 没有必要给出拒绝的详细理由，可以在实体的主体部分对原因进行描述

- 404 Not Found
	- 表明服务器上无法找到请求的资源。
	- 也可以再服务器端拒绝请求且不想说吗理由时使用。

### 4.5 5XX服务器错误
表明服务器本身发生错误。

- 500 Internal Server Error
	- 表明服务器端在执行请求时发生了错误。
	- 也有可能是Web应用存在的bug或者某些临时的故障

- 503 Service Unavailable
	- 表明服务器暂时处于超负载或者正在进行停机维护，现无法处理请求。
	- 如果事先知道解决以上状况需要的世界，最好写入RetryAfter首部字段再返回给客户端。

状态码和状况的不一致。不少返回的状态码响应都是错误的。

## 第五章 与HTTP协作的Web服务器
一台Web服务器可搭建多个独立域名的web网站，也可作为通信路径上的中转服务器提升传输效率。

### 5.1 用单台虚拟主机实现多个域名
即使只有一台服务器，只要使用虚拟主机的功能，则可以假想已具有多台服务器。

若两个网站同时部署在同一个服务器上（相同的IP地址），使用DNS服务解析域名后，两者的访问IP地址会相同。  
因此在发送HTTP请求时，必须在Host首部内完整指定主机名或域名的URI。

### 5.2 通信数据转发程序：代理、网关、隧道
HTTP通信时，除客户端和服务器以外，还有一些用于通信数据转发的应用程序，例如代理、网关、隧道。它们可以配合服务器工作。

- 代理：
	- 有转发功能的应用程序，扮演了中间人的角色在服务器和客户端中。
	- 每次通过代理服务器转发请求或响应时，会追加写入Via首部信息以标记出经过的主机信息。
	- 使用代理的理由：
		- 利用缓存技术减少网络带宽的流量
		- 组织内部针对特定网站的访问控制
		- 以获取访问日志为主要目的
	- 使用代理的方法：
		- 一种是是否使用缓存
		- 另一种是是否会修改报文
	- 透明代理：不对报文做任何加工的代理类型。
- 网关：
	- 转发其他服务器通信数据的服务器，像自己拥有资源的源服务器一样对请求进行处理。有时客户端可能都不会察觉，自己的通信目标是一个网关。
	- 能提高通信的安全性（例如网站用信用卡结算，网关可以和信用卡结算系统联动）
- 隧道：
	- 隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。
	- 使用SSL等加密手段进行通信。确保客户端与服务器进行安全的通信。
	- 不会去解析HTTP请求，原样中转。隧道会在通信双方断开连接时结束。

### 5.3 保存资源的缓存
缓存是指代理服务器或客户端本地磁盘内保存的资源副本。  
可减少对源服务器的访问，节省了通信流量和通信时间。

缓存服务器是代理服务器的一种，并归类在缓存代理类型中。但代理转发从服务器返回的响应时，代理服务器将会保存一份资源的副本。  
请求的资源如果已经被缓存则直接由缓存服务器返回给客户端。  
有缓存有效期限

客户端的缓存。存在客户端浏览器中。但判定缓存过期后，会向源服务器确认资源的有效性。若判断浏览器缓存失败，浏览器会再次请求新资源。

## 第六章 HTTP首部
HTTP协议的请求和响应报文中必定包含HTTP首部。  
首部内容为客户端和服务器分别处理请求和响应提供所需要的信息
### 6.1 HTTP报文首部
![][image-10]

HTTP请求报文由方法、URI、HTTP版本、HTTP首部字段等部分构成。  
HTTP响应报文由HTTP版本、状态码（数字和原因短语）、HTTP不受字段3部分构成。  

HTTP首部字段包含的信息最为丰富。  
HTTP首部字段同时存在于请求和响应报文内，并涵盖HTTP报文相关的内容信息。

### 6.2 HTTP首部字段
#### 6.2.1 HTTP首部字段传递重要信息  
使用首部字段是为了给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容。

#### 6.2.2 HTTP首部字段结构
HTTP首部字段是由首部字段名和字段值构成的，中间用“：”分。  
`首部字段名：字段值`  
`例如：Content-Type: text/html`  
字段值对应单个HTTP首部字段可以有很多个值，例如 ：  
`Keep-Alive: timeout=15, max=100`  
如果HTTP首部字段重复了，根据浏览器内部处理的逻辑不通，结果可能不一致。有的会优先处理第一次出现的，有的则会优先处理最后的。

#### 6.2.3 4种HTTP首部字段类型  
HTTP首部字段根据实际用途被分为以下4种类型：

- General Header Fields 通用首部字段
	- 请求报文和响应报文两方都会使用的首部。
- Request Header Fields 请求首部字段
	- 从客户端向服务器端发送请求报文时使用的首部。
	- 补充了请求的附加内容、客户端信息、响应内容相关优先级等信息
- Response Header Fields 响应首部字段
	- 从服务器向客户端返回响应报文时使用的首部。
	- 补充了响应的附加内容，也会要求客户端附加额外的内容信息。
- Entity Header Fields 实体首部字段
	- 针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息。

#### 6.2.4 HTTP/1.1 首部字段一览
略。

#### 6.2.5 非HTTP/1.1 首部字段
还有Cookie、Set-Cookie和Content-Disposition等在其他首部字段，他们的使用频率也很高。

#### 6.2.6 End-to-End 首部和 Hop-by-hop首部
HTTP首部字段将定义成缓存代理和非缓存代理的行为，分为2种类型：  

- End-to-End 首部 端到端首部
	- 此类首部会转发给请求/响应对应的最终接收目标，且必须保存在由缓存生成的响应中另外规定它必须被转发。
- Hop-by-hop首部 逐跳首部
	- 此类的首部只对单次转发有效，会因通过缓存或代理而不再转发。  
	- HTTP/1.1和之后的版本中，如果要使用hop-by-hop首部，需提供Connection首部字段。
	- 以下八个是逐跳首部，其余都是端到端首部：
		- Connection
		- Keep-Alive
		- Proxy-Authenticate
		- Proxy-Authorization
		- Trailer
		- TE
		- Transfer-Encoding
		- Upgrade

### 6.3 HTTP/1.1 通用首部字段 General Header Fields
通用首部字段 General Header Fields指的是，请求报文和响应报文双方都会使用的首部。

#### 6.3.1 Cache-Control  控制缓存的行为
指令的参数是可选的，多个指令之间通过“,”分隔。  
![][image-11]
![][image-12]

- Cache-Control: no-cache
	- 为了防止从缓存中返回过期的资源
	- 客户端发出的请求中包含`no-cache `指令，那客户端不会接受缓存过的响应。中间的缓存服务器必须把客户端请求转发给源服务器。
	- 服务器返回的响应中包含`no-cache `指令，那缓存服务器不能对资源进行缓存。源服务器以后也将不再对缓存服务器请求中提出的资源有效性进行确认，且禁止其对响应资源进行缓存
	-  Cache-Control: no-cache=Location
		- 只能在响应指令中指定该参数
		- 无参数值的首部字段可以使用缓存。

- Cache-Control: no-store
	- 不缓存
	- 区别于`no-cache`，事实上`no-cache`代表不缓存过期的资源。


指定缓存期限和认证的指令：

-  Cache-Control: s-maxage= （秒）
	- s-maxage指令只适用于供多位用户使用的公共缓存服务器。使用s-maxage指令后，则直接忽略对Expires首部字段及max-age指令的处理。
- Cache-Control: max-age= （秒） 
	- 客户端发送的请求包含max-age指令时，如果缓存资源的缓存时间数比指定时间的数值小，那客户端接收缓存资源。另外，当指定max-age值为0，那么缓存服务器将请求转发给源服务器。
	- 服务器返回的响应中包含max-age指令，缓存服务器将不对资源的有效性再做确认，而max-age数值代表资源保存为缓存的最长时间。
	- 若同时存在Expires首部字段的情况时，会优先处理max-age指令，而忽略掉Expires首部字段。

- Cache-Control: min-fresh= （秒）
	- 要求服务器返回至少还未过指定时间的缓存资源

- 另外，使用 must-revalidate 指令会忽略请求的 max-stale 指令（即使已经在首部使用了 max-stale，也不会再有效果）。

#### 6.3.2 Connection
Connection 首部字段具备如下两个作用：

- 控制不再转发给代理的首部字段
	- Connection: 不再转发的首部字段名
	-  在客户端发送请求和服务器返回响应内，使用 Connection 首部字段，可控制不再转发给代理的首部字段（即 Hop-by-hop 首部）。
![][image-13]

- 管理持久连接
	- Connection: close 
		- HTTP/1.1 版本的默认连接都是持久连接。为此，客户端会在持久连接上连续发送请求。当服务器端想明确断开连接时，则指定 Connection 首部字段的值为 Close。
	- Connection: Keep-Alive
		-  HTTP/1.1 之前的 HTTP 版本的默认连接都是非持久连接。为此，如果想在旧版本的 HTTP 协议上维持持续连接，则需要指定 Connection 首部字段的值为 Keep-Alive。

#### 6.3.3 Date
首部字段 Date 表明创建 HTTP 报文的日期和时间。

#### 6.3.4 Pragma
是HTTP/1.1 之前版本的历史遗留字段，仅作为与HTTP/1.0的向后兼容而定义  
`Pragma: no-cache`  
虽然是通用首部字段，但只用在客户端发送的请求中。客户端会要求所有的中间服务器不返回缓存的资源。  
所有的中间服务器如果都能以 HTTP/1.1 为基准，那直接采用 `Cache-Control: no-cache `指定缓存的处理方式是最为理想的。但要整体掌握全部中间服务器使用的 HTTP 协议版本却是不现实的。因此，发送的请求会同时含有下面两个首部字段。 

	Cache-Control: no-cache
	Pragma: no-cache

#### 6.3.5 Trailer
首部字段 Trailer 会事先说明在报文主体后记录了哪些首部字段。该首部字段可应用在 HTTP/1.1 版本分块传输编码时。
![][image-14]

#### 6.3.6 Transfer-Encoding
规定了传输报文主体时采用的编码方式  
HTTP/1.1传输编码方式仅对分块传输编码有效。  
`Transfer-Encoding: Chunked`

#### 6.3.7 Upgrade
用于检测HTTP协议及其他协议是否可以使用更高的版本进行通信，其参数值可以用来指定一个完全不同的通信协议。
![][image-15]

#### 6.3.8 Via
为了追踪客户端与服务器之间的请求和响应报文的传输路径。  
报文经过代理或者网关时，会现在首部字段Via中附加该服务器的信息，再进行转发。  
首部字段Via不仅用于追踪报文的转发，还可避免请求回环的发生。所以必须经过代理时附加该首部字段内容。  
Via首部是为了追踪传输路径，所以经常会和TRACE方法一起使用。

#### 6.3.9 Warning
告知用户一些与缓存相关的问题的警告  
格式如下：最后的日期时间部分可省略。  
`Warning: [警告码][警告的主机：端口号]“[警告内容]”([日期时间])`
![][image-16]

### 6.4 请求首部字段
请求首部字段是从客户端往服务器发送请求报文中所使用的字段。用于补充请求的附加信息、客户端信息、对响应内容相关的优先级等内容。

#### 6.4.1 Accept
Accept 首部字段可通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。可使用 type/subtype 这种形式，一次指定多种媒体类型。

	e.g.
	Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8

若想要给显示的媒体类型增加优先级，则使用 q= 来额外表示权重值 1，用分号（;）进行分隔。权重值 q 的范围是 0\~1（可精确到小数点后 3 位），且 1 为最大值。不指定权重 q 值时，默认权重为 q=1.0。


#### 6.4.2 Accept-Charset
首部字段可用来通知服务器用户代理支持的**字符集及字符集的相对优先顺序**。另外，可一次性指定多种字符集。与首部字段 Accept 相同的是可用权重 q 值来表示相对优先级。

该首部字段应用于内容协商机制的服务器驱动协商。

#### 6.4.3 Accept-Encoding
首部字段用来告知服务器用户代理支持的**内容编码及内容编码的优先级顺序**。可一次性指定多种内容编码。

	Accept-Encoding: gzip, deflate

#### 6.4.4 Accept-Language
用来告知服务器用户代理能够处理的自然语言集（指中文或英文等），以及自然语言集的相对优先级。可一次指定多种自然语言集。  
和 Accept 首部字段一样，按权重值 q 来表示相对优先级。在下面例子中，客户端在服务器有中文版资源的情况下，会请求其返回中文版对应的响应，没有中文版时，则请求返回英文版响应。

	Accept-Language: zh-cn,zh;q=0.7,en-us,en;q=0.3

#### 6.4.5 Authorization
是用来告知服务器，用户代理的认证信息（证书值）。  
通常，想要通过服务器认证的用户代理会在接收到返回的401 状态码Unauthorized响应后，把首部字段 Authorization 加入请求中。

#### 6.4.6 Except
客户端使用首部字段 Expect 来告知服务器，期望出现的某种特定行为。  
因服务器无法理解客户端的期望作出回应而发生错误时，会返回状态码417 Expectation Failed  
客户端可以利用该首部字段，写明所期望的扩展。虽然 HTTP/1.1 规范只定义了 100-continue（状态码 100 Continue 之意）。 等待状态码 100 响应的客户端在发生请求时，需要指定 `Expect:100-continue`。

#### 6.4.7 From
用来告知服务器使用用户代理的用户的电子邮件地址。  
通常，其使用目的就是为了显示搜索引擎等用户代理的负责人的电子邮件联系方式。  
使用代理时，应尽可能包含 From 首部字段（但可能会因代理不同，将电子邮件地址记录在 User-Agent 首部字段内）。

#### 6.4.8 Host
虚拟主机运行在同一个 IP 上，因此使用首部字段 Host 加以区分  
首部字段 Host 会告知服务器，请求的资源所处的互联网主机名和端口号。

#### 6.4.9 If-Match
形如 If-xxx 这种样式的请求首部字段，都可称为条件请求。  
服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求。  

**只有当 If-Match 的字段值跟 ETag 值匹配一致时，服务器才会接受请求**

#### 6.4.10 If-Modified-Since
If-Modified-Since 用于确认代理或客户端拥有的本地资源的有效性。获取资源的更新日期时间，可通过确认首部字段 Last-Modified 来确定。

首部字段 If-Modified-Since，属附带条件之一，它会告知服务器若 If-Modified-Since 字段值早于资源的更新时间，则希望能处理该请求。而在指定 If-Modified-Since 字段值的日期时间之后，如果请求的资源都没有过更新，则返回状态码 304  Not Modified

#### 6.4.11 If-None-Match
只有在 If-None-Match 的字段值与 ETag 值不一致时，可处理该请求。与 If-Match 首部字段的作用相反

#### 6.4.12 If-Range
首部字段 If-Range 属于附带条件之一。它告知服务器若指定的 If-Range 字段值（ETag 值或者时间）和请求资源的 ETag 值或时间相一致时，则作为范围请求处理。反之，则返回全体资源。

#### 6.4.13 If-Unmodified-Since
首部字段 If-Unmodified-Since 和首部字段 If-Modified-Since 的作用相反。它的作用的是告知服务器，指定的请求资源只有在字段值内指定的日期时间之后，未发生更新的情况下，才能处理请求。如果在指定日期时间后发生了更新，则以状态码 412 Precondition Failed 作为响应返回。

#### 6.4.14 Max-Forwards

	Max-Forwards: 10

每次转发数值减 1。当数值变 0 时返回响应

#### 6.4.15　Proxy-Authorization
`Proxy-Authorization: Basic dGlwOjkpNLAGfFY5`

接收到从代理服务器发来的认证质询时，客户端会发送包含首部字段 Proxy-Authorization 的请求，以告知服务器认证所需要的信息。

#### 6.4.16　Range
`Range: bytes=5001-10000`
对于只需获取部分资源的范围请求，包含首部字段 Range 即可告知服务器资源的指定范围。上面的示例表示请求获取从第 5001 字节至第 10000 字节的资源。 接收到附带 Range 首部字段请求的服务器，会在处理请求之后返回状态码为 206 Partial Content 的的响应。无法处理该范围请求时，则会返回状态码 200 OK 的响应及全部资源。

#### 6.4.17 Referer
`Referer: http://www.hackr.jp/index.htm   `
首部字段 Referer 会告知服务器请求的原始资源的 URI。  
 客户端一般都会发送 Referer 首部字段给服务器。但当直接在浏览器的地址栏输入 URI，或出于安全性的考虑时，也可以不发送该首部字段  

因为原始资源的 URI 中的查询字符串可能含有 ID 和密码等保密信息，要是写进 Referer 转发给其他服务器，则有可能导致保密信息的泄露。  

另外，Referer 的正确的拼写应该是 Referrer，但不知为何，大家一直沿用这个错误的拼写。

#### 6.4.18 TE
`TE: gzip, deflate;q=0.5 `
首部字段 TE 会告知服务器客户端能够处理响应的传输编码方式及相对优先级。它和首部字段 Accept-Encoding 的功能很相像，但是用于传输编码。

#### 6.4.19 User-Agent
User-Agent 用于传达浏览器的种类 

	User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:13.0) Gecko/20100101 Firefox/13.0.1 

首部字段 User-Agent 会将创建请求的浏览器和用户会将创建请求的浏览器和用户代理名称等信息传达给服务器。

### 6.5 响应首部字段
响应首部字段是服务器向客户端返回响应报文中所使用的字段。  
可以补充响应的附加信息、服务器信息，以及对客户端的附加要求等信息。

#### 6.5.1　Accept-Ranges
`Accept-Ranges: bytes`  
 首部字段 Accept-Ranges 是用来告知客户端服务器是否能处理范围请求，以指定获取服务器端某个部分的资源。 可指定的字段值有两种，可处理范围请求时指定其为 byte  
当不能处理范围请求时，`Accept-Ranges: none`

#### 6.5.2　Age
首部字段 Age 能告知客户端，源服务器在多久前创建了响应。字段值的单位为秒。
若创建该响应的服务器是缓存服务器，Age 值是指缓存后的响应再次发起认证到认证完成的时间值。代理创建响应时必须加上首部字段 Age。

#### 6.5.3　ETag
定义：  
首部字段 ETag 能告知客户端实体标识。它是一种可将资源以字符串形式做唯一性标识的方式。服务器会为每份资源分配对应的 ETag 值。  

资源更新时，URI相同 ，Etag值也需要更新，由服务器分配

使用中英文版本网站的Etag值不同，即使URI相同。  

强 ETag 值和弱 Tag 值 ：  
ETag 中有强 ETag 值和弱 ETag 值之分。  
 强 ETag 值  
强 ETag 值，不论实体发生多么细微的变化都会改变其值。  
`ETag: "usagi-1234"`  
 
弱 ETag 值  
弱 ETag 值只用于提示资源是否相同。只有资源发生了根本改变，产生差异时才会改变ETag值。这时会在字段值最开始处附加W/  
`ETag: W/"usagi-1234" `

#### 6.5.4 Location
使用首部字段 Location 可以将响应接收方引导至某个与请求 URI 位置不同的资源。 基本上，该字段会配合 3xx ：Redirection 的响应，提供重定向的 URI。
![][image-17]

#### 6.5.5 Proxy-Authenticate
`Proxy-Authenticate: Basic realm=“Usagidesign Auth”`  
首部字段 Proxy-Authenticate 会把由代理服务器所要求的认证信息发送给客户端。 它与客户端和服务器之间的 HTTP 访问认证的行为相似，不同之处在于其认证行为是在客户端与代理之间进行的。而客户端与服务器之间进行认证时，首部字段 WWW-Authorization 有着相同的作用。

#### 6.5.6 Retry-After
`Retry-After: 120`  
 首部字段 Retry-After 告知客户端应该在多久之后再次发送请求。主要配合状态码 503 Service Unavailable 响应，或 3xx Redirect 响应一起使用。  

 字段值可以指定为具体的日期时间（Wed, 04 Jul 2 2012 06：34：24 GMT 等格式），也可以是创建响应后的秒数。

#### 6.5.7 Server
`Server: Apache/2.2.17 (Unix) `  
首部字段 Server 告知客户端当前服务器上安装的 HTTP 服务器应用程序的信息。不单单会标出服务器上的软件应用名称，还有可能包括版本号和安装时启用的可选项。  
` Server: Apache/2.2.6 (Unix) PHP/5.2.5`

#### 6.5.8 Vary
首部字段 Vary 可对缓存进行控制。源服务器会向代理服务器传达关于本地缓存使用方法的命令。  
`Vary: Accept-Language `
#### 6.5.9　WWW-Authenticate
` WWW-Authenticate: Basic realm="Usagidesign Auth"   `  
首部字段 WWW-Authenticate 用于 HTTP 访问认证。它会告知客户端适用于访问请求 URI 所指定资源的认证方案（Basic 或是 Digest）和带参数提示的质询（challenge）。  
状态码 401 Unauthorized 响应中，肯定带有首部字段 WWW-Authenticate

上述示例中，realm 字段的字符串是为了辨别请求 URI 指定资源所受到的保护策略。有关该首部，请参阅本章之后的内容。
  

### 6.6 实体首部字段
实体首部字段是**包含在请求报文和响应报文中的实体部分**所使用的首部  
用于补充内容的更新时间等与实体相关的信息内容

#### 6.6.1 Allow
`Allow: GET, HEAD`  
 首部字段 Allow 用于通知客户端能够支持 Request-URI 指定资源的所有 HTTP 方法。  
当服务器接收到不支持的 HTTP 方法时，会以状态码 405 Method Not Allowed 作为响应返回。与此同时，还会把所有能支持的 HTTP 方法写入首部字段 Allow 后返回。

#### 6.6.2 Content-Encoding
`Content-Encoding: gzip`
会告知客户端服务器对实体的主体部分选用的内容编码方式。内容编码是指在不丢失实体信息的前提下所进行的压缩。  
主要采用以下 4 种内容编码的方式。（各方式的说明请参考 6.4.3 节 Accept-Encoding 首部字段）。

-  gzip 
- compress
-  deflate
-  identity

#### 6.6.3 Content-Language
`Content-Language: zh-CN `  
首部字段 Content-Language 会告知客户端，实体主体使用的自然语言（指中文或英文等语言）。

#### 6.6.4 Content-Length
`Content-Length: 15000`  
 首部字段 Content-Length 表明了实体主体部分的大小（单位是字节）。对实体主体进行内容编码传输时，不能再使用

#### 6.6.5　Content-Location
`Content-Location: http://www.hackr.jp/index-ja.html `  
首部字段 Content-Location 给出与报文主体部分相对应的 URI。和首部字段 Location 不同，Content-Location 表示的是报文主体返回资源对应的 URI。  

比如，对于使用首部字段 Accept-Language 的服务器驱动型请求，当返回的页面内容与实际请求的对象不同时，首部字段 Content-Location 内会写明 URI。（访问 http://www.hackr.jp/ 返回的对象却是 http://www.hackr.jp/index-ja.html

#### 6.6.6 Content-MD5  
首部字段 Content-MD5 是一串由 MD5 算法生成的值，其目的在于检查报文主体在传输过程中是否保持完整，以及确认传输到达。

#### 6.6.7 Content-Range
`Content-Range: bytes 5001-10000/10000 `  
针对范围请求，返回响应时使用的首部字段 Content-Range，能告知客户端作为响应返回的实体的哪个部分符合范围请求。字段值以字节为单位，表示当前发送部分及整个实体大小。

#### 6.6.8　Content-Type
`Content-Type: text/html; charset=UTF-8  `  
首部字段 Content-Type 说明了实体主体内对象的媒体类型。和首部字段 Accept 一样，字段值用 type/subtype 形式赋值。

#### 6.6.9 Expires
`Expires: Wed, 04 Jul 2012 08:26:05 GMT `  
首部字段 Expires 会将资源失效的日期告知客户端。  

缓存服务器在接收到含有首部字段 Expires 的响应后，会以缓存来应答请求，在 Expires 字段值指定的时间之前，响应的副本会一直被保存。当超过指定的时间后，缓存服务器在请求发送过来时，会转向源服务器请求资源。  

源服务器不希望缓存服务器对资源缓存时，最好在 Expires 字段内写入与首部字段 Date 相同的时间值。 但是，当首部字段 Cache-Control 有指定max-age 指令时，比起首部字段 Expires，会优先处理 max-age 指令。

#### 6.6.10 Last-Modified
`Last-Modified: Wed, 23 May 2012 09:59:55 GMT`  
 首部字段 Last-Modified 指明资源最终修改的时间。

### 6.7 为Cookie服务的首部字段
管理服务器与客户端之间状态的 Cookie

工作机制：  
Cookie 的工作机制是用户识别及状态管理。

为Cookie服务的首部字段：  
![][image-18]
![][image-19]

#### 6.7.1 Set-Cookie
当服务器准备开始管理客户端的状态时，会事先告知各种信息。

`Set-Cookie: status=enable; expires=Tue, 05 Jul 2011 07:26:31 GMT; path=/; domain=.hackr.jp;`

**Set-Cookie 字段的属性**

- expires属性 
	- 指定浏览器可发送Cookie的有效期
	- 省略的话，有效期限于维持浏览器会话（session）时间段内。
	- 一旦从服务器发送至客户端，服务器就不存在可以显式删除Cookie的方法，但可以覆盖已过期的Cookie，实现删除操作。

- path属性：
	- 用于限制指定Cookie的发送范围的文件目录。
	- 不过有办法可以避开

- domain属性
	- 通过domain属性指定的域名可做到与结尾匹配一致
		- 比如，当指定 example.com 后，除 example.com 以外，www.example.com 或 www2.example.com 等都可以发送 Cookie。 
		- 因此，除了针对具体指定的多个域名发送 Cookie 之 外，不指定 domain属性更安全。
- secure属性
	- 用于限制 Web 页面仅在 HTTPS 安全连接时，才可以发送 Cookie。
	- `Set-Cookie: name=value; secure `
	- 就算是同域名，但不是https，就不会发生Cookie回收行为。

- HttpOnly属性
	- 是Cookie的扩展功能，使JavaScript脚本无法获得Cookie。
	- 目的是防止跨站脚本攻击（XSS）对Cookie的信息窃取
	-  `Set-Cookie: name=value; HttpOnly `

#### 6.7.2 Cookie
`Cookie: status=enable`  
首部字段 Cookie 会告知服务器，当客户端想获得 HTTP 状态管理支持时，就会在请求中包含从服务器接收到的 Cookie。接收到多个 Cookie 时，同样可以以多个 Cookie 形式发送。

### 6.8 其他首部字段
HTTP 首部字段是可以自行扩展的。所以在 Web 服务器和浏览器的应用上，会出现各种非标准的首部字段。

最为常用的首部字段：  

- X-Frame-Options 
	- `X-Frame-Options: DENY `
	- 属于 HTTP 响应首部，用于控制网站内容在其他 Web 网站的 Frame 标签内的显示问题。
	- 其主要目的是为了防止点击劫持（clickjacking）攻击。
	- 两个可指定的字段值：
		- DENY:拒绝
		- SAMEORIGIN: 仅同源域名下的页面匹配时许可。
			- 比如，当指定 http://hackr.jp/sample.html 页面为 SAMEORIGIN 时，那么 hackr.jp 上所有页面的 frame 都被允许可加载该页面，而 example.com等其他域名的页面就不行。
- X-XSS-Protection
	- `X-XSS-Protection : 1`
	- 属于 HTTP 响应首部，它是针对跨站脚本攻击（XSS）的一种对策，用于控制浏览器 XSS 防护机制的开关。
	- 两个可指定的字段值：
		- 0: 将XSS过滤设置成无效状态
		- 1：将XSS过滤设置成有效状态
-  DNT 
	- `DNT:1`
	- 属于 HTTP 请求首部，其中 DNT 是 Do Not Track 的简称，意为拒绝个人信息被收集，是表示拒绝被精准广告追踪的一种方法。
	- 两个可指定的字段值：
		- 0: 同意被追踪
		- 1：拒绝被追踪
- P3P
	- 属于 HTTP 相应首部，通过利用 P3P（The Platform for Privacy Preferences，在线隐私偏好平台）技术，可以让 Web 网站上的个人隐私变成一种仅供程序可理解的形式，以达到保护用户隐私的目的。

## 第七章 确保Web安全的HTTPS
在 HTTP 协议中有可能存在信息窃听或身份伪装等安全问题。使用 HTTPS 通信机制可以有效地防止这些问题。

### 7.1 HTTP的缺点

- 通信使用明文（不加密），内容可能会被窃听
-  不验证通信方的身份，因此有可能遭遇伪装 
- 无法证明报文的完整性，所以有可能已遭篡改

#### 7.1.1　通信使用明文可能会被窃听
因为HTTP本身不具备加密功能，所以HTTP报文都使用明文方式进行发送。

- TCP/IP是可能被窃听的网络
	- 按 TCP/IP 协议族的工作机制，通信内容在所有的通信线路上都有可能遭到窥视。
- 加密处理防止被窃听
	- 最为普及的加密技术：
		- 将通讯加密。
			- 通过SSL或者TLS的组合使用，加密HTTP的通信内容
			- 用 SSL 建立安全通信线路之后，就可以在这条线路上进行 HTTP 通信了。
			- 与 SSL 组合使用的 HTTP 被称为 HTTPS（HTTP Secure，超文本传输安全协议）或 HTTP over SSL。
		- 内容的加密
			- 即把 HTTP 报文里所含的内容进行加密处理。
			- 在这种情况下，客户端需要对 HTTP 报文进行加密处理后再发送请求。
				- 报文首部不被加密/报文主体会被加密处理（通信本身是不加密的）
			-有一点必须引起注意，由于该方式不同于 SSL 或 TLS 将整个通信线路加密处理，所以内容仍有被篡改的风险。稍后我们会加以说明。

#### 7.1.2 不验证通信方的身份就可能遭遇伪装
HTTP 协议中的请求和响应不会对通信方进行确认。也就是说存在“服务器是否就是发送请求中 URI 真正指定的主机，返回的响应是否真的返回到实际提出请求的客户端”等类似问题。

- 任何人都可发起请求
	- 谁都可以发起请求
	- 服务器只要接收到请求，都会返回一个响应
		- 无法确定请求发送至目标的 Web 服务器是否是按真实意图返回响应的那台服务器。有可能是已伪装的 Web 服务器。 
		- 无法确定响应返回到的客户端是否是按真实意图接收响应的那个客户端。有可能是已伪装的客户端。
		-  无法确定正在通信的对方是否具备访问权限。因为某些 Web 服务器上保存着重要服务器上保存着重要的信息，只想发给特定用户通信的权限。 
		- 无法判定请求是来自何方、出自谁手。
		-  即使是无意义的请求也会照单全收。无法阻止海量请求下的 DoS 攻击（Denial of Service，拒绝服务攻击）。

- 查明对手的证书
	- HTTP无法确认通信方，但使用SSL可以。
	- SSL不仅提供加密处理，还使用一种被称为证书的手段，可用于确认方。
	- 证书由值得信任的第三方机构颁发，用以证明服务器和客户端是实际存在的。
	- 伪造证书从技术角度来说是异常困难的一件事。所以只要能够确认通信方（服务器或客户端）持有的证书，即可判断通信方的真实意图。

![][image-20]

#### 7.1.3 无法证明报文完整性，可能已被篡改
所谓完整性是指信息的准确度。若无法证明其完整性，通常也就意味着无法判断信息是否准确。

- 接收到的内容可能有误
	- 无法确认发出的和接收到的是否前后相同。
	- 这种在传输途中，遭攻击者拦截并篡改内容的攻击称为**中间人攻击**

- 如何防止篡改
	- 有必要使用 HTTPS。SSL 提供认证和加密处理及摘要功能。

### 7.2　HTTP+ 加密 + 认证 + 完整性保护 =HTTPS
HTTP 加上加密处理和认证以及完整性保护后即是 HTTPS

#### 7.2.2　HTTPS 是身披 SSL 外壳的 HTTP
**HTTPS 并非是应用层的一种新协议。**只是 HTTP 通信接口部分用 SSL（Secure Socket Layer）和 TLS（Transport Layer Security）协议代替而已。  
通常，HTTP 直接和 TCP 通信。当使用 SSL 时，则演变成先和 SSL 通信，再由 SSL 和 TCP 通信了。

#### 7.2.3 相互交换密钥的公开密钥加密技术
SSL 采用一种叫做公开密钥加密（Public-key cryptography）的加密处理方式。

- 公开密钥加密使用一对非对称的密钥。一把叫做私有密钥（private key），另一把叫做公开密钥（public key）。  
	使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。  
- HTTPS 采用混合加密机制
	-  HTTPS 采用共享密钥加密和公开密钥加密两者并用的混合加密机制。若密钥能够实现安全交换，那么有可能会考虑仅使用公开密钥加密来通信。

#### 7.2.4　证明公开密钥正确性的证书
公开密钥加密方式还是存在一些问题的，所以无法证明公开密钥的货真价实性。  

为了解决上述问题，可以使用由数字证书认证机构（CA，Certificate Authority）和其相关机关颁发的公开密钥证书。

- 可证明组织真实性的 EV SSL 证书
- 用以确认客户端的客户端证书
- 认证机构信誉第一
- 由自认证机构颁发的证书称为自签名证书

#### 7.2.5 HTTPS的安全通信机制
![][image-21]

SSL 的慢分两种。一种是指通信慢。另一种是指由于大量消耗 CPU 及内存等资源，导致处理速度变慢。 和使用 HTTP 相比，网络负载可能会变慢 2 到 100 倍。除去和 TCP 连接、发送 HTTP 请求 • 响应以外，还必须进行 SSL 通信，因此整体上处理通信量不可避免会

为什么不一直使用 HTTPS 既然 HTTPS 那么安全可靠，那为何所有的 Web 网站不一直使用 HTTPS ？  
 其中一个原因是，因为与纯文本通信相比，加密通信会消耗更多的 CPU 及内存资源。如果每次通信都加密，会消耗相当多的资源，平摊到一台计算机上时，能够处理的请求数量必定也会随之减少。  
因此，如果是非敏感信息则使用 HTTP 通信，只有在包含个人信息等敏感数据时，才利用 HTTPS 加密通信。
其次，证书的开销也是原因。

## 第八章  确认访问用户身份的认证
### 8.1 何为认证
HTTP/1.1 使用的认证方式如下所示

- BASIC 认证（基本认证） 
- DIGEST 认证（摘要认证）
-  SSL 客户端认证
-  FormBase 认证（基于表单认证）

### 8.2 BASIC 认证（基本认证）
是 Web 服务器与通信客户端之间进行的认证方式。  
采用Base64编码方式，不是加密处理。  
并不常用

### 8.3 DIGEST 认证（摘要认证）
DIGEST 认证同样使用质询 / 响应的方式（challenge/response），但不会像 BASIC 认证那样直接发送明文密码。  

 所谓**质询响应方式**是指，一开始一方会先发送认证要求给另一方，接着使用从另一方那接收到的质询码计算生成响应码。最后将响应码返回给对方进行认证的方式
![][image-22] 
![][image-23] 

DIGEST 认证提供了高于 BASIC 认证的安全等级，但是和 HTTPS 的客户端认证相比仍旧很弱。DIGEST 认证提供防止密码被窃听的保护机制，但并不存在防止用户伪装的保护机制。  
 DIGEST 认证和 BASIC 认证一样，使用上不那么便捷灵活，且仍达不到多数 Web 网网站对高度安全等级的追求标准。因此它的适用范围也有所受限。

### 8.4 SSL客户端认证
如果用户 ID 和密码被盗，就很有可能被第三者冒充。利用 SSL 客户端认证则可以避免该情况的发生。  
SSL 客户端认证是借由 HTTPS 的客户端证书完成认证的方式。凭借客户端证书认证，服务器可确认访问是否来自已登录的客户端。

#### 8.4.1 SSL客户端认证的认证步骤
![][image-24]

#### 8.4.2　SSL 客户端认证采用双因素认证
在多数情况下，SSL 客户端认证不会仅依靠证书完成认证，一般会和基于表单认证（稍后讲解）组合形成一种双因素认证（Two-factor authentication）来使用。  

所谓**双因素认证**就是指，认证过程中不仅需要密码这一个因素，还需要申请认证者提供其他持有信息，从而作为另一个因素，与其组合使用的认证方式。  

例如： 一个认证因素的SSL客户端证书用来认证客户端计算机，另一个认证因素的密码则用来确定这是用户本人的行为。

还有！ SSL客户端认证必要费用也很高昂。

### 8.5 FormBase 认证（基于表单认证）
客户端会向服务器上的 Web 应用程序发送登录信息（Credential），按登录信息的验证结果认证。

#### 8.5.1　认证多半为基于表单认证
因为安全性，不怎么使用BASIC认证和DIGEST认证。  
SSL客户端郑仁虽然高度安全，但导入及维持费用等问题，尚未普及。

#### 8.5.2　Session 管理及 Cookie 应用
 基于表单认证的标准规范尚未有定论，一般会使用 Cookie 来管理 Session（会话）。
 ![][image-25]
 ![][image-26]

## 第九章 基于HTTP的功能追加协议
### 9.2　消除 HTTP 瓶颈的 SPDY
Google 在 2010 年发布了 SPDY（取自 SPeeDY，发音同 speedy），其开发目标旨在解决 HTTP 的性能瓶颈，缩短 Web 页面的加载时间（50%）。

#### 9.2.1  HTTP的瓶颈

**Ajax 的解决方法   **
Ajax（Asynchronous JavaScript and XML， 异 步 JavaScript 与 XML 技术）是一种有效利用 JavaScript 和 DOM（Document Object Model，文档对象模型）的操作，以达到局部 Web 页面替换加载的异步通信手段。和以前的同步通信相比，由于它只更新一部分页面，响应中传输的数据量会因此而减少，这一优点显而易见。

**核心技术：** Ajax 的核心技术是名为 XMLHttpRequest 的 API，通过 JavaScript 脚本语言的调用就能和服务器进行 HTTP 通信。借由这种手段，就能从已加载完毕的 Web 页面上发起请求，只更新局部页面。  

**缺点：** 而利用 Ajax 实时地从服务器获取内容，有可能会导致大量请求产生。另外，Ajax 仍未解决 HTTP 协议本身存在的问题。  

**Comet 的解决方法**  
 一旦服务器端有内容更新了，Comet 不会让请求等待，而是直接给客户端返回响应。这是一种通过延迟应答，模拟实现服务器端向客户端推送（Server Push）的功能。  

通常，服务器端接收到请求，在处理完毕后就会立即返回响应，但为了实现推送功能，Comet 会先将响应置于挂起状态，当服务器端有内容更新时，再返回该响应。因此，服务器端一旦有更新，就可以立即反馈给客户端。  

**缺点** 内容上虽然可以做到实时更新，但为了保留响应，一次连接的持续时间也变长了。期间，为了维持连接会消耗更多的资源。另外，Comet 也仍未解决 HTTP 协议本身存在的问题。  

__ 处于持续开发状态中的 SPDY 协议，正是为了在协议级别消除 HTTP 所遭遇的瓶颈。__

#### 9.2.2 SPDY的设计与功能
SPDY 没有完全改写 HTTP 协议，而是在 TCP/IP 的应用层与运输层之间通过新加会话层的形式运作。同时，考虑到安全性问题，SPDY 规定通信中使用 SSL。  

SPDY 以会话层的形式加入，控制对数据的流动，但还是采用 HTTP 建立通信连接。因此，可照常使用 HTTP 的 GET 和 POST 等方 法、Cookie 以及 HTTP 报文等。

![][image-27]

使用SPDY后，HTTP协议额外获得以下功能：  

- 多路复用流
	- 使用一条TCP连接，无限处理多个HTTP请求，效率得到提高
- 赋予请求优先级
	- 可以给请求逐个分配优先顺序。解决了因带宽而导致响应变慢的问题。
- 压缩HTTP首部
	- 压缩HTTP请求和响应的首部。减少通信产生的数据包数量和发送的字节数。
- 推送功能
	- 支持服务器主动向客户端推送数据的功能。
- 服务器提示功能
	- 服务器可以主动提示客户端请求所需的资源。由于在客户端发现资源之前就可以获知资源的存在，因此在资源已缓存等情况下，可以避免发送不必要的请求。

** SPDY 的确是一种可有效消除 HTTP 瓶颈的技术，但很多 Web 网站存在的问题并非仅仅是由 HTTP 瓶颈所导致。对 Web 本身的速度提升，还应该从其他可细致钻研的地方入手，比如改善 Web 内容的编写方式等。**

### 9.3　使用浏览器进行全双工通信的 WebSocket
Ajax和Comet技术可以提升浏览速度，但使用HTTP协议，就无法彻底解决瓶颈问题。**WebSocket是一套新的协议和API**  

定为标准。仍在开发中的 WebSocket 技术主要是为了解决 Ajax 和 Comet 里 XMLHttpRequest 附带的缺陷所引起的问题。

#### 9.3.2 WebSocket协议
一旦 Web 服务器与客户端之间建立起 WebSocket 协议的通信连接，之后所有的通信都依靠这个专用协议进行。通信过程中可互相发送 JSON、XML、HTML 或图片等任意格式的数据。  

因为建立在HTTP协议基础上，所以发起连接的仍是客户端，而一旦确立WebSocket通信连接，服务器和客户端都可直接向对方发送报文。

**WebSocket协议的主要特点**  

- 推送功能
	- 服务器可以向客户端推送，不会都能带客户端的请求。
- 减少通信量
	- 一直保持连接状态。和 HTTP 相比，不但每次连接时的总开销减少，而且由于 WebSocket 的首部信息很小，通信量也相应减少了。


**实现WebSocket通信**  
为了实现WebSocket通信 ，在HTTP连接建立之后，需要完成一次“握手”的步骤。
![][image-28]
![][image-29]
![][image-30]


### 9.4 HTTP/2.0
![][image-31]

### 9.5 Web服务器管理文件的WebDAV
**WebDAV（Web-based Distributed Authoring and Versioning**，基于万维网的分布式创作和版本控制）是一个可对 Web 服务器上的内容直接进行文件复制、编辑等操作的分布式文件系统。  

除了创建、删除文件等基本功能，它还具备文件创建者管理、文件编辑过程中禁止其他用户内容覆盖的加锁功能，以及对文件内容修改的版本控制功能。

#### 9.5.1  扩展HTTP/1.1 的WebDAV
针对服务器上的资源，WebDAV 新增加了一些概念，如下所示。
![][image-32]
![][image-33]

## 第十章 构建Web内容的技术

- HTML
- CSS
- Javascript

#### 10.3.2 与Web服务器与程序协作的CGI
CGI（Common Gateway Interface，通用网关接口）是指 Web 服务器在接收到客户端发送过来的请求后转发给程序的一组机制。在 CGI 的作用下，程序会对请求内容做出相应的动作，比如创建 HTML 等动态内容。

使用 CGI 的程序叫做 CGI 程序，通常是用 Perl、PHP、Ruby 和 C 等编程语言编写而成。

#### 10.3.3 因Java而普及的Servlet
Servlet1 是一种能在服务器上创建动态内容的程序。Servlet 是用 Java 语言实现的一个接口，属于面向企业级 Java（JavaEE，Java Enterprise Edition）的一部分。

CGI与Servlet的区别：  
CGI每次接到请求，程序都要跟着启动一次，导致一旦访问量过大，服务器需要承担相当大的负载。  
而Servelet运行与Web服务器相同的进程中，因此受到的负载较小。Servlet的运行环境叫做Web容器或Servlet容器。

### 10.4 数据发布的格式及语言
XML是一种可按应用目标进行扩展的🙆标记语言。通过使用XML，使互联网数据共享变得更容易。  
与HTML相比，它对数据的记录方式做了特殊处理。  

XML 和 HTML 一样，使用标签构成树形结构，并且可自定义扩展标签。  
 从 XML 文档中读取数据比起 HTML 更为简单。由于 XML 的结构基本上都是用标签分割而成的树形结构，因此通过语法分析器（Parser）的解析功能解析 XML 结构并取出数据元素，可更容易地对数据进行

#### 10.4.2 发布更新信息的RSS/Atom
RSS（简易信息聚合，也叫聚合内容）和 Atom 都是发布新闻或博客日志等更新信息文档的格式的总称。两者都用到了XML。

#### 10.4.3 JSON
JSON（JavaScript Object Notation）是一种以 JavaScript（ECMAScript）的对象表示法为基础的轻量级数据标记语言。能够处理的数据类型有 false/null/true/ 对象 / 数组 / 数字 / 字符串，这 7 种类型。

[image-1]:	1.png
[image-2]:	2.png
[image-3]:	3.png
[image-4]:	4.png
[image-5]:	5.png
[image-6]:	6.png
[image-7]:	7.png
[image-8]:	8.png
[image-9]:	9.png
[image-10]:	10.png
[image-11]:	11.png
[image-12]:	12.png
[image-13]:	13.png
[image-14]:	14.png
[image-15]:	15.png
[image-16]:	16.png
[image-17]:	17.png
[image-18]:	18.png
[image-19]:	19.png
[image-20]:	20.png
[image-21]:	21.png
[image-22]:	22.png
[image-23]:	23.png
[image-24]:	24.png
[image-25]:	25.png
[image-26]:	26.png
[image-27]:	27.png
[image-28]:	28.png
[image-29]:	29.png
[image-30]:	30.png
[image-31]:	31.png
[image-32]:	32.png
[image-33]:	33.png