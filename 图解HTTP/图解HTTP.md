# 图解HTTP

## 第一章 了解Web及网络基础
### 1.1 使用HTTP协议访问web

- 通过发送请求获取服务器资源的Web浏览器等，都可以称为**客户端(client)**
![][image-1]

### 1.3 网络基础TCP/IP
通常使用的网络（包括互联网）是在TCP/IP协议族的基础运作的。而HTTP属于它内部的一个子集。
#### 1.3.2 TCP/IP的分层管理
TCP/IP协议族按层次分为

- 应用层
	-  决定了向用户提供应用服务时通信的活动（例如FTP(File Transfer Protocol)/DNS(Domain Name System)等）
	- HTTP协议处于该层
- 传输层
	- 对上层应用层，提供了网络连接中的两台计算机之间的数据传输
	- 传输层有两个性质不同的协议：TCP(Transmission Control Protocol)和UDP(User Data Protocol)
- 网络层
	- 用来处理在网络上流动的数据包（是网络传输的最小数据）。
	- 规定了通过怎样的路径（就是传输路线）到达对方计算机，并把数据包传送给对方
- 数据链路层
	- 用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（网卡），及光纤等物理课件部分。硬件范畴均在链路层。

#### 1.3.3 TCP/IP 通信传输流
![][image-2]

利用TCP/IP协议族进行网络通信时，会通过分成顺序与对方进行通信。  
发送端从应用层往下走，接收端则往上走。  

**封装**：发送端在层与层之间的传输数据时，每经过一层时必定会被打上一个改层所属的首部信息。反之，接收端在层与层传输数据时，每经过一一层时，会把对应的首部消去。

### 1.4 与HTTP关系密切的协议:IP、TCP和DNS
#### 1.4.1 负责传输的IP协议
IP（Internet Protocol）网际协议位于网络层 ，是协议名称，有别于IP地址 
作用就是把各种数据包传送给对方，为确保传送到对方那里，需要满足条件，其中两个重要的条件是IP地址和MAC地址

- IP地址指明了节点分配的地址（可变换）
- MAC地址指的是网卡所属的固定地址（基本不会改）
- 使用ARP协议凭借MAC地址进行通信
- IP间的通信以来MAC地址，因为通信双方在同一个局域网内的情况很少，在进行中转时，会利用下一站中转设备的MAC地址来搜索下一个中转目标。
	- 这时采用ARP协议（Address Resolution Protocol），是一种用以解析地址的协议，根据通信方的IP地址就可以反查出对应的MAC地址。

![][image-3]

#### 1.4.2 确保可靠性的TCP协议
桉层次分，TCP位于传输层，提供可靠的字节流服务。
也就是，TCP协议为了更容易传送大数据才把数据分割，而且TCP协议能够确认数据最终是否送达到对方。

为了准确无误地将数据送达目标处，TCP协议采用了**三次握手**策略。（使用了TCP的标准——SYN（synchronize）和ACK（acknowledge））

- 发送端首先发送一个带SYN标志的数据包给对方
- 接收端收到后回传一个带有SYN/ACK标志的数据包以示传达确认信息
- 发送端再回传一个带ACK标准的数据包，代表握手结束

### 1.5 负责域名解析的DNS服务
DNS（Domain Name System）服务是和HTTP协议一样位于应用层的协议。提供域名和IP地址之间的解析服务。  
用户通常通过主机名或域名来访问对方的计算机，而不是直接通过IP地址。  
计算机不理解名称，更擅长处理一长串数字。  
DNS协议提供通过域名查找IP地址，或逆向从IP地址反查域名的服务

### 1.6 各种协议与HTTP协议的关系
![][image-4]

### 1.7 URI 和URL
与URI（统一资源标识符）相比，我们更熟悉URL（Uniform Resource Locator，统一资源定位符）。
#### 1.7.1 URI 统一资源标识符
URI = Uniform Resource Identifier  
URI用字符串标识某一互联网资源，而URL表示资源的地点（互联网上所处的位置）。URL是URI的子集。


#### 1.7.2 URI格式

- 绝对URI
	- 使用http或者https等协议方案名获取访问资源时要指定协议类型。最后附一个冒号：
- 绝对URL
- 相对URL：指从浏览器中基本URI处指定的URL，形如/image/logo.gif
- …

## 第二章 简单的HTTP协议
### 2.1 HTTP协议用于客户端和服务器端之间
应用HTTP协议时，必定一端是客户端，一端是服务器端。

### 2.2
HTTP协议规定，请求从客户端发出，最后服务器端响应请求并返回。服务器端在没有接到请求之前是不会发送响应的。
![][image-5]

请求报文：  

- 方法（method）：GET/POST
- 请求URI（request-URI）：e.g /index.htm
- HTTP版本号，用来提示客户端使用的HTTP协议功能。 e.g HTTP/1.1
- (可选)请求首部字段
- (可选)内容实体

![][image-6]

响应报文：

- HTTP版本号
- 状态码
- 状态码的原因短语
- (可选)创建响应的日期时间，是首部字段内的一个属性
- (可选)主体

### 2.3 HTTP是不保存状态的协议
HTTP是一种不保存状态的协议，即无状态协议。HTTP协议自身不对请求和响应之间的通信状态进行保存。  
为了保存状态功能，引入了Cookie技术。

### 2.4 请求URI定位资源
URI的特定功能，在互联网上任意位置的资源都能访问到。  
HTTP协议使用URI让客户端定位资源  
当客户端请求访问资源而发送请求时，URI需要将作为请求报文中的请求URI包含在内。如果不是访问特定资源，而是对服务器本身发起请求，可以用一个\*来代替URI。`OPTIONS * HTTP/1.1`

### 2.5 告知服务器意图的HTTP方法
HTTP/1.1中可以使用的方法：

- GET：获取资源
- POST： 传输实体主体
- PUT：传输文件 （不带验证机制，存在安全问题。一般不使用）
- HEAD：获得报文首部
	- 和GET方法一样，只是不返回报文主题部分。
	- 用于确认URI的有效性及资源更新的日期时间等

- DELETE：删除文件
	- 与PUT相反，按请求URI删除指定的资源
	- 同样不带验证机制，存在安全问题。一般不使用

- OPTIONS：询问支持的方法
	- 查询针对请求URI指定的资源支持的方法
![][image-7]

- TRACE:追踪路径
	- 不常用，容易引发XST攻击（跨站追踪）
- CONNECT：要求用隧道协议链接代理
	- 要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL和TLS协议把通信内容加密后经网络隧道传输

### 2.7 持久连接节省通信量
只要任意一端没有明确提出断开连接，则保持TCP连接状态

#### 2.7.2 管线化：
持久连接使得多数请求以管线化方式发送成为可能。以前发送请求后需要等待并收到响应才能发生下一个请求。管线化技术的出现，不用等待响应亦可直接发送下一个请求。这样可以同时并行发送多个请求。

### 2.8 使用Cookie的状态管理
Cookie会根据从服务器端发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在报文中加入Cookie值发送出去。  
服务器端发现客户端发送过来的Cookie后，检查从哪一个客户端发来的连接请求，然后对比服务器的记录，最后得到之前的状态信息。

## 第三章 HTTP报文内的HTTP信息
### 3.1 HTTP报文
HTTP报文大致可分为报文首部和报文主体两块。两者由最初出现的空行（回车符➕换行符）来划分。不一定要有报文主体。

- 报文首部：服务器端或者客户端需处理的请求或响应的内容及属性
- 报文主体：应被发送的数据

### 3.2 请求报文及响应报文的结构

- 请求行/状态行
	- 请求行：包含用于请求的方法，请求URI和HTTP版本
	- 状态行：包含表明响应结果的状态码，原因短语和HTTP版本

- 首部字段：包含请求和新颖的各种条件和属性的各类首部
	- 通用首部
	- 请求首部
	- 响应首部
	- 实体首部
	- （可能包含HTTP和RFC里未定义的首部（Cookie等））。

### 3.3编码提升传输速率
#### 3.3.1 报文主体和实体主体的差异

- 报文（message）
	- HTTP通信的基本单位
	- 8位组字节流组成
	- 通过HTTP通信传输

- 实体（entity）
	- 作为请求或者响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成

HTTP报文的主体用于传输请求或者响应的实体主体。  
通常，报文主体等于实体主体。  
只有当传输中进行编码操作时，实体主体的内容发生变化，才有差异。

#### 3.3.2 压缩传输的内容编码
HTTP协议中有一种被称为内容编码的功能也能进行类似ZIP压缩的操作。  
内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩。  
内容编码后的实体由客户端接收并且负责解码。  
常见内容编码有以下几种： 

- gzip
- compress
- delate
- identity

#### 3.3.3 分割发送的分块传输编码
在HTTP通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。  
在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。  
这种把实体主体分块的功能称为分块传输编码。

#### 3.4 发送多种数据的多部分对象集合
HTTP协议中采用了多部分对象集合，发送一份报文主体内可含有多类型的实体。通常是在图片或文本文件等上传时使用。  
多部分对象集合包含的对象如下：

- multipart/form-data
	- 在Web表单文件上传使用
- multipart/byterangers
	- 状态码206（Partial Content，部分内容）响应报文包含了多个范围的内容时使用。
![][image-8]
![][image-9]

在HTTP报文中使用多部分对象集合时，需要在首部字段里加上`Content-type`  
使用boundary字符串来划分多部分对象集合指明的各类实体。 在各个实体的起始行之前插入“\-\-”标记(例如：\-\-AaB03x-\-、-\-THIS\_STRING\_SEPARATES-\-）作为结束

### 3.5 获取部分内容的范围请求
以前不使用高速网络，如果下载网络中断就必须重新开始。为解决这个问题，需要一种可恢复机制。  
要实现该功能需要指定下载的实体范围。  
指定范围发送的请求叫做范围请求（range request）  

执行范围请求时，会用到`Range`来指定资源的byte范围。

	byte范围的指定形式如下：
	        5001~10000字节
	        Range:bytes=5001~10000
	        从5001字节之后全部的
	        Range: byte=5001-
	        从一开始到3000字节和5000~7000字节的多重范围
	        Range: byte=-3000, 5000-7000

针对范围请求，响应会返回状态码206 Partial Content的响应报文。  
对于多重范围的范围请求，响应会在首部字段`Content-Type`标明`multipart/byteranges`后返回响应报文  
如果服务器无法响应范围请求，则会但会状态码200 OK和完整的实体内容。

### 3.6 内容协商返回最合适的内容
同一个web网站可能保存多份相同内容的页面。比如英语版和中文版的WEB页面，内容虽相同，语言却不同。  
但浏览器的默认语言为英语或中文，访问相同URI的web页面时，则会显示对应的英语版或者中文版。这样的机制成为**内容协商（Content Negotiation）**  

内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源，内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准。

包含在请求报文中的某些首部字段就是判断基准：

- Accept
- Accept-Charset
- Accept-Encoding
- Accept-Language
- Content-Language

内容协商技术有以下3种类型：

- 服务器驱动协商（server-driven Negotiation）
	- 以请求的首部字段为参考，在服务器自动处理。但不一定是最优内容
- 客户端驱动协商（agent-driven negotiation）
	- 用户从浏览器显示的可选项列表手动选择。还可以利用JavaScript脚本在web页面上自动进行上述选择。例如按OS的类型或者浏览器类型，自行切换成PC版网页或手机版网页
- 透明协商（Transparent Negotiation）
	- 两种的结合体。各自进行内容协商的一种方法。

## 第四章 返回结果的HTTP状态码
HTTP状态码负责表示客服端HTTP请求的返回结果、标记服务器端的处理是否正常、通知出现的错误等工作。

状态码的第一位指定了响应类别。  
状态码的类别：

- 1XX（Informational 信息性） 接收的请求正在处理
- 2XX （Success 成功状态码）请求正常处理完毕
- 3XX （Redirection 重定向状态码）需要进行附加操作以完成请求
- 4XX （Client Error 客户端错误状态码）服务器无法处理请求
- 5XX （Server Error 服务器错误状态码）服务器处理请求出错

### 4.2 2XX 成功 success
请求正常处理完毕

- 200 OK 
	- 表示从客服端发来的请求在服务器端被正常处理了

在响应报文内，随状态码一起返回的信息会因方法的不同而发生变化。  
使用GET方法时，对应请求资源的实体会作为响应返回。  
使用HEAD方法时，对应请求资源的实体首部不随报文主体作为响应返回。（即在响应中只返回首部，不会返回实体的主体部分）

- 204 No Content
	-  请求处理成功！但没有资源可返回。
	- 一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。

- 206 Partial Content
	- 表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。
	- 响应报文中包含由Content-Range指定范围的实体内容。

### 4.3 3XX 重定向 redirection
表明浏览器需要执行某些特殊的处理以正确处理请求

- 301 Moved Permanently
	- 永久性重定向
	- 请求的资源以及被分配了新的URI，以后应使用资源现在所指定的URI。
	- 如果以及把URI保存为书签，这时应该按Locaiton首部字段提示的URI重新保存
	- 例如这个路径最后忘记添加‘/’,就会产生301状态码`http://example.com/sample`

- 302 Found
	- 临时性重定向
	- 表示请求的资源已被分配了新的URI，希望用户（本次）能使用新的URI访问
	- 与301对比，302是临时性的，已移动的资源对应的URI将来还有可能发生改变。
	- 用户把URI保存成书签，但不会像301状态码那样去更新书签，而是仍旧保留返回302状态码的页面对应的URI

- 303 See Other
	- 表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。
	- 303和302有着相同的功能，但303明确表示客户端应当采用GET方法获取资源。

当301、302、303响应状态码返回时，几乎所有浏览器都会把POST改成GET，并删除请求报文内的主体，之后请求会自动再次发送。  
301、302标准是禁止将POST改变成GET方法的，但实际使用时大家都会这么做。

- 304 Not Modified
	- 表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。
	- 304返回时，不包含任何响应的主体部分。
	- 304虽然被划分在3XX类别中，但是和重定向没有关系。

- 307 Temporary Redirect
	- 临时重定向。与302有相同含义，尽管302标准禁止POST变换成GET,但大家并不遵守。
	- 307会遵守浏览器标准，不会从POST变成GET。但是，对于处理响应时的行为，每种浏览器有可能出现不同的情况。

### 4.4 4XX客户端错误 client error
表明客户端是发生错误的原因所在。

- 400 Bad Request
	- 表示请求报文中存在语法错误。
	- 当错误发生时，需修改请求的内容后再次发送请求。
	- 浏览器会像200 OK一样对待该状态码。

- 401 Unauthorized 
	- 表示发送的请求需要有通过HTTP认证的认证信息。
	- 若之前已经进行过1次请求，则表示用户认证失败。
	- 返回含有401的响应必须包含一个适用于被请求资源的WWW-Authenticate首部用以质询用户信息。初次接到401响应时，会弹出认证用的对话窗口。

- 403 Forbidden
	- 表明对请求资源的访问被服务器拒绝了。
	- 没有必要给出拒绝的详细理由，可以在实体的主体部分对原因进行描述

- 404 Not Found
	- 表明服务器上无法找到请求的资源。
	- 也可以再服务器端拒绝请求且不想说吗理由时使用。

### 4.5 5XX服务器错误
表明服务器本身发生错误。

- 500 Internal Server Error
	- 表明服务器端在执行请求时发生了错误。
	- 也有可能是Web应用存在的bug或者某些临时的故障

- 503 Service Unavailable
	- 表明服务器暂时处于超负载或者正在进行停机维护，现无法处理请求。
	- 如果事先知道解决以上状况需要的世界，最好写入RetryAfter首部字段再返回给客户端。

状态码和状况的不一致。不少返回的状态码响应都是错误的。

## 第五章 与HTTP协作的Web服务器
一台Web服务器可搭建多个独立域名的web网站，也可作为通信路径上的中转服务器提升传输效率。

### 5.1 用单台虚拟主机实现多个域名
即使只有一台服务器，只要使用虚拟主机的功能，则可以假想已具有多台服务器。

若两个网站同时部署在同一个服务器上（相同的IP地址），使用DNS服务解析域名后，两者的访问IP地址会相同。  
因此在发送HTTP请求时，必须在Host首部内完整指定主机名或域名的URI。

### 5.2 通信数据转发程序：代理、网关、隧道
HTTP通信时，除客户端和服务器以外，还有一些用于通信数据转发的应用程序，例如代理、网关、隧道。它们可以配合服务器工作。

- 代理：
	- 有转发功能的应用程序，扮演了中间人的角色在服务器和客户端中。
	- 每次通过代理服务器转发请求或响应时，会追加写入Via首部信息以标记出经过的主机信息。
	- 使用代理的理由：
		- 利用缓存技术减少网络带宽的流量
		- 组织内部针对特定网站的访问控制
		- 以获取访问日志为主要目的
	- 使用代理的方法：
		- 一种是是否使用缓存
		- 另一种是是否会修改报文
	- 透明代理：不对报文做任何加工的代理类型。
- 网关：
	- 转发其他服务器通信数据的服务器，像自己拥有资源的源服务器一样对请求进行处理。有时客户端可能都不会察觉，自己的通信目标是一个网关。
	- 能提高通信的安全性（例如网站用信用卡结算，网关可以和信用卡结算系统联动）
- 隧道：
	- 隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。
	- 使用SSL等加密手段进行通信。确保客户端与服务器进行安全的通信。
	- 不会去解析HTTP请求，原样中转。隧道会在通信双方断开连接时结束。

### 5.3 保存资源的缓存
缓存是指代理服务器或客户端本地磁盘内保存的资源副本。  
可减少对源服务器的访问，节省了通信流量和通信时间。

缓存服务器是代理服务器的一种，并归类在缓存代理类型中。但代理转发从服务器返回的响应时，代理服务器将会保存一份资源的副本。  
请求的资源如果已经被缓存则直接由缓存服务器返回给客户端。  
有缓存有效期限

客户端的缓存。存在客户端浏览器中。但判定缓存过期后，会向源服务器确认资源的有效性。若判断浏览器缓存失败，浏览器会再次请求新资源。

## 第六章 HTTP首部
HTTP协议的请求和响应报文中必定包含HTTP首部。  
首部内容为客户端和服务器分别处理请求和响应提供所需要的信息
### 6.1 HTTP报文首部
![][image-10]

HTTP请求报文由方法、URI、HTTP版本、HTTP首部字段等部分构成。  
HTTP响应报文由HTTP版本、状态码（数字和原因短语）、HTTP不受字段3部分构成。  

HTTP首部字段包含的信息最为丰富。  
HTTP首部字段同时存在于请求和响应报文内，并涵盖HTTP报文相关的内容信息。

### 6.2 HTTP首部字段
#### 6.2.1 HTTP首部字段传递重要信息  
使用首部字段是为了给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容。

#### 6.2.2 HTTP首部字段结构
HTTP首部字段是由首部字段名和字段值构成的，中间用“：”分。  
`首部字段名：字段值`  
`例如：Content-Type: text/html`  
字段值对应单个HTTP首部字段可以有很多个值，例如 ：  
`Keep-Alive: timeout=15, max=100`  
如果HTTP首部字段重复了，根据浏览器内部处理的逻辑不通，结果可能不一致。有的会优先处理第一次出现的，有的则会优先处理最后的。

#### 6.2.3 4种HTTP首部字段类型  
HTTP首部字段根据实际用途被分为以下4种类型：

- General Header Fields 通用首部字段
	- 请求报文和响应报文两方都会使用的首部。
- Request Header Fields 请求首部字段
	- 从客户端向服务器端发送请求报文时使用的首部。
	- 补充了请求的附加内容、客户端信息、响应内容相关优先级等信息
- Response Header Fields 响应首部字段
	- 从服务器向客户端返回响应报文时使用的首部。
	- 补充了响应的附加内容，也会要求客户端附加额外的内容信息。
- Entity Header Fields 实体首部字段
	- 针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息。

#### 6.2.4 HTTP/1.1 首部字段一览
略。

#### 6.2.5 非HTTP/1.1 首部字段
还有Cookie、Set-Cookie和Content-Disposition等在其他首部字段，他们的使用频率也很高。

#### 6.2.6 End-to-End 首部和 Hop-by-hop首部
HTTP首部字段将定义成缓存代理和非缓存代理的行为，分为2种类型：  

- End-to-End 首部 端到端首部
	- 此类首部会转发给请求/响应对应的最终接收目标，且必须保存在由缓存生成的响应中另外规定它必须被转发。
- Hop-by-hop首部 逐跳首部
	- 此类的首部只对单次转发有效，会因通过缓存或代理而不再转发。  
	- HTTP/1.1和之后的版本中，如果要使用hop-by-hop首部，需提供Connection首部字段。
	- 以下八个是逐跳首部，其余都是端到端首部：
		- Connection
		- Keep-Alive
		- Proxy-Authenticate
		- Proxy-Authorization
		- Trailer
		- TE
		- Transfer-Encoding
		- Upgrade

### 6.3 HTTP/1.1 通用首部字段 General Header Fields
通用首部字段 General Header Fields指的是，请求报文和响应报文双方都会使用的首部。

#### 6.3.1 Cache-Control  控制缓存的行为
指令的参数是可选的，多个指令之间通过“,”分隔。  
![][image-11]
![][image-12]

- Cache-Control: no-cache
	- 为了防止从缓存中返回过期的资源
	- 客户端发出的请求中包含`no-cache `指令，那客户端不会接受缓存过的响应。中间的缓存服务器必须把客户端请求转发给源服务器。
	- 服务器返回的响应中包含`no-cache `指令，那缓存服务器不能对资源进行缓存。源服务器以后也将不再对缓存服务器请求中提出的资源有效性进行确认，且禁止其对响应资源进行缓存
	-  Cache-Control: no-cache=Location
		- 只能在响应指令中指定该参数
		- 无参数值的首部字段可以使用缓存。

- Cache-Control: no-store
	- 不缓存
	- 区别于`no-cache`，事实上`no-cache`代表不缓存过期的资源。


指定缓存期限和认证的指令：

-  Cache-Control: s-maxage= （秒）
	- s-maxage指令只适用于供多位用户使用的公共缓存服务器。使用s-maxage指令后，则直接忽略对Expires首部字段及max-age指令的处理。
- Cache-Control: max-age= （秒） 
	- 客户端发送的请求包含max-age指令时，如果缓存资源的缓存时间数比指定时间的数值小，那客户端接收缓存资源。另外，当指定max-age值为0，那么缓存服务器将请求转发给源服务器。
	- 服务器返回的响应中包含max-age指令，缓存服务器将不对资源的有效性再做确认，而max-age数值代表资源保存为缓存的最长时间。
	- 若同时存在Expires首部字段的情况时，会优先处理max-age指令，而忽略掉Expires首部字段。

- Cache-Control: min-fresh= （秒）
	- 要求服务器返回至少还未过指定时间的缓存资源

- 另外，使用 must-revalidate 指令会忽略请求的 max-stale 指令（即使已经在首部使用了 max-stale，也不会再有效果）。

#### 6.3.2 Connection
Connection 首部字段具备如下两个作用：

- 控制不再转发给代理的首部字段
	- Connection: 不再转发的首部字段名
	-  在客户端发送请求和服务器返回响应内，使用 Connection 首部字段，可控制不再转发给代理的首部字段（即 Hop-by-hop 首部）。
![][image-13]

- 管理持久连接
	- Connection: close 
		- HTTP/1.1 版本的默认连接都是持久连接。为此，客户端会在持久连接上连续发送请求。当服务器端想明确断开连接时，则指定 Connection 首部字段的值为 Close。
	- Connection: Keep-Alive
		-  HTTP/1.1 之前的 HTTP 版本的默认连接都是非持久连接。为此，如果想在旧版本的 HTTP 协议上维持持续连接，则需要指定 Connection 首部字段的值为 Keep-Alive。

#### 6.3.3 Date
首部字段 Date 表明创建 HTTP 报文的日期和时间。

#### 6.3.4 Pragma
是HTTP/1.1 之前版本的历史遗留字段，仅作为与HTTP/1.0的向后兼容而定义  
`Pragma: no-cache`  
虽然是通用首部字段，但只用在客户端发送的请求中。客户端会要求所有的中间服务器不返回缓存的资源。  
所有的中间服务器如果都能以 HTTP/1.1 为基准，那直接采用 `Cache-Control: no-cache `指定缓存的处理方式是最为理想的。但要整体掌握全部中间服务器使用的 HTTP 协议版本却是不现实的。因此，发送的请求会同时含有下面两个首部字段。 

	Cache-Control: no-cache
	Pragma: no-cache

#### 6.3.5 Trailer
首部字段 Trailer 会事先说明在报文主体后记录了哪些首部字段。该首部字段可应用在 HTTP/1.1 版本分块传输编码时。
![][image-14]

#### 6.3.6 Transfer-Encoding
规定了传输报文主体时采用的编码方式  
HTTP/1.1传输编码方式仅对分块传输编码有效。  
`Transfer-Encoding: Chunked`

#### 6.3.7 Upgrade
用于检测HTTP协议及其他协议是否可以使用更高的版本进行通信，其参数值可以用来指定一个完全不同的通信协议。
![][image-15]

#### 6.3.8 Via
为了追踪客户端与服务器之间的请求和响应报文的传输路径。  
报文经过代理或者网关时，会现在首部字段Via中附加该服务器的信息，再进行转发。  
首部字段Via不仅用于追踪报文的转发，还可避免请求回环的发生。所以必须经过代理时附加该首部字段内容。  
Via首部是为了追踪传输路径，所以经常会和TRACE方法一起使用。

#### 6.3.9 Warning
告知用户一些与缓存相关的问题的警告  
格式如下：最后的日期时间部分可省略。  
`Warning: [警告码][警告的主机：端口号]“[警告内容]”([日期时间])`
![][image-16]

### 6.4 请求首部字段
请求首部字段是从客户端往服务器发送请求报文中所使用的字段。用于补充请求的附加信息、客户端信息、对响应内容相关的优先级等内容。

#### 6.4.1 Accept
Accept 首部字段可通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。可使用 type/subtype 这种形式，一次指定多种媒体类型。

	e.g.
	Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8

若想要给显示的媒体类型增加优先级，则使用 q= 来额外表示权重值 1，用分号（;）进行分隔。权重值 q 的范围是 0\~1（可精确到小数点后 3 位），且 1 为最大值。不指定权重 q 值时，默认权重为 q=1.0。


#### 6.4.2 Accept-Charset
首部字段可用来通知服务器用户代理支持的**字符集及字符集的相对优先顺序**。另外，可一次性指定多种字符集。与首部字段 Accept 相同的是可用权重 q 值来表示相对优先级。

该首部字段应用于内容协商机制的服务器驱动协商。

#### 6.4.3 Accept-Encoding
首部字段用来告知服务器用户代理支持的**内容编码及内容编码的优先级顺序**。可一次性指定多种内容编码。

	Accept-Encoding: gzip, deflate

#### 6.4.4 Accept-Language
用来告知服务器用户代理能够处理的自然语言集（指中文或英文等），以及自然语言集的相对优先级。可一次指定多种自然语言集。  
和 Accept 首部字段一样，按权重值 q 来表示相对优先级。在下面例子中，客户端在服务器有中文版资源的情况下，会请求其返回中文版对应的响应，没有中文版时，则请求返回英文版响应。

	Accept-Language: zh-cn,zh;q=0.7,en-us,en;q=0.3

#### 6.4.5 Authorization
是用来告知服务器，用户代理的认证信息（证书值）。  
通常，想要通过服务器认证的用户代理会在接收到返回的401 状态码响应后，把首部字段 Authorization 加入请求中。

#### 6.4.6 Except
客户端使用首部字段 Expect 来告知服务器，期望出现的某种特定行为。  
因服务器无法理解客户端的期望作出回应而发生错误时，会返回状态码417 Expectation Failed  
客户端可以利用该首部字段，写明所期望的扩展。虽然 HTTP/1.1 规范只定义了 100-continue（状态码 100 Continue 之意）。 等待状态码 100 响应的客户端在发生请求时，需要指定 `Expect:100-continue`。

#### 6.4.7 From
用来告知服务器使用用户代理的用户的电子邮件地址。  
通常，其使用目的就是为了显示搜索引擎等用户代理的负责人的电子邮件联系方式。  
使用代理时，应尽可能包含 From 首部字段（但可能会因代理不同，将电子邮件地址记录在 User-Agent 首部字段内）。

#### 6.4.8 Host
虚拟主机运行在同一个 IP 上，因此使用首部字段 Host 加以区分  
首部字段 Host 会告知服务器，请求的资源所处的互联网主机名和端口号。

#### 6.4.9 If-Match
形如 If-xxx 这种样式的请求首部字段，都可称为条件请求。  
服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求。  

**只有当 If-Match 的字段值跟 ETag 值匹配一致时，服务器才会接受请求**

#### 6.4.10 If-Modified-Since
If-Modified-Since 用于确认代理或客户端拥有的本地资源的有效性。获取资源的更新日期时间，可通过确认首部字段 Last-Modified 来确定。

首部字段 If-Modified-Since，属附带条件之一，它会告知服务器若 If-Modified-Since 字段值早于资源的更新时间，则希望能处理该请求。而在指定 If-Modified-Since 字段值的日期时间之后，如果请求的资源都没有过更新，则返回状态码 304 

#### 6.4.11 If-None-Match
只有在 If-None-Match 的字段值与 ETag 值不一致时，可处理该请求。与 If-Match 首部字段的作用相反

#### 6.4.12 If-Range
首部字段 If-Range 属于附带条件之一。它告知服务器若指定的 If-Range 字段值（ETag 值或者时间）和请求资源的 ETag 值或时间相一致时，则作为范围请求处理。反之，则返回全体资源。

#### 6.4.13 If-Unmodified-Since
首部字段 If-Unmodified-Since 和首部字段 If-Modified-Since 的作用相反。它的作用的是告知服务器，指定的请求资源只有在字段值内指定的日期时间之后，未发生更新的情况下，才能处理请求。如果在指定日期时间后发生了更新，则以状态码 412 Precondition Failed 作为响应返回。

#### 6.4.14 Max-Forwards

	Max-Forwards: 10

每次转发数值减 1。当数值变 0 时返回响应

#### 6.4.15　Proxy-Authorization 
`Proxy-Authorization: Basic dGlwOjkpNLAGfFY5`

接收到从代理服务器发来的认证质询时，客户端会发送包含首部字段 Proxy-Authorization 的请求，以告知服务器认证所需要的信息。

#### 6.4.16　Range 
`Range: bytes=5001-10000`
对于只需获取部分资源的范围请求，包含首部字段 Range 即可告知服务器资源的指定范围。上面的示例表示请求获取从第 5001 字节至第 10000 字节的资源。 接收到附带 Range 首部字段请求的服务器，会在处理请求之后返回状态码为 206 Partial Content 的的响应。无法处理该范围请求时，则会返回状态码 200 OK 的响应及全部资源。

#### 6.4.17 Referer
`Referer: http://www.hackr.jp/index.htm   `
首部字段 Referer 会告知服务器请求的原始资源的 URI。  
 客户端一般都会发送 Referer 首部字段给服务器。但当直接在浏览器的地址栏输入 URI，或出于安全性的考虑时，也可以不发送该首部字段  

因为原始资源的 URI 中的查询字符串可能含有 ID 和密码等保密信息，要是写进 Referer 转发给其他服务器，则有可能导致保密信息的泄露。   

另外，Referer 的正确的拼写应该是 Referrer，但不知为何，大家一直沿用这个错误的拼写。

#### 6.4.18 TE
`TE: gzip, deflate;q=0.5 `
首部字段 TE 会告知服务器客户端能够处理响应的传输编码方式及相对优先级。它和首部字段 Accept-Encoding 的功能很相像，但是用于传输编码。

#### 6.4.19 User-Agent
User-Agent 用于传达浏览器的种类 

	User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:13.0) Gecko/20100101 Firefox/13.0.1 

首部字段 User-Agent 会将创建请求的浏览器和用户会将创建请求的浏览器和用户代理名称等信息传达给服务器。

[image-1]:	1.png
[image-2]:	2.png
[image-3]:	3.png
[image-4]:	4.png
[image-5]:	5.png
[image-6]:	6.png
[image-7]:	7.png
[image-8]:	8.png
[image-9]:	9.png
[image-10]:	10.png
[image-11]:	11.png
[image-12]:	12.png
[image-13]:	13.png
[image-14]:	14.png
[image-15]:	15.png
[image-16]:	16.png